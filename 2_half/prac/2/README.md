# Практическая работа 2. "Сравнение скорости работы динамического массива и односвязного списка"

>Необходимо написать динамический массив и односвязный список. 
>
>Далее необходимо написать два стека: на списке и на массиве.
>
>
>У стеков должны быть следующие функции:
>
>* struct Stack* stack_ctr(size_t size, size_t element_size) 
>  создает массив заданного размера, который потом будет изменяться в ходе исполнения (только для массива)
>
>
>* int push(struct Stack* st, void* buffer) 
>  Добавляет элемент в конец контейнера, возвращает 1 если добавление успешно, 0 - не успешно
>
>
>* int top(struct Stack* st, void* buffer) 
>  Возвращает последний элемент
>
>
>* int pop(struct Stack* st) 
>  Удаляет последний элемент, не возвращая его, возвращает 1 - если успех 0 - если ошибка
>
>
>* struct Stack* stack_dtr(struct Stack* st) 
>  Уничтожает контейнер, освобождая память, возвращает nullptr


## Далее провести для них следующие тесты (каждый провести хотя бы по три раза и усреднить время тестов):


>### Тест 1
>Надо запушить  `10^6` интов, потом удалить половину элементов и запушить четверть - останется 750000 интов. Повторять удаление половины и вставку четверти, пока не останется в стеке меньше 100000 элементов (получится 9 итераций).

Результаты:

| измерение              | обычный стек, ms | стек на листе, ms |
|------------------------|------------------|-------------------|
| 1                      | 17.322           | 312.486           |
| 2                      | 17.080           | 310.937           |
| 3                      | 17.834           | 313.484           |
| среднее время          | 17.4 $\pm$ 0.4   | 312.3 $\pm$ 1.3   |
| отностельное ускорение | 18.0 $\pm$ 0.5   | 1.00 (baseline)   |

>### Тест 2
>Надо запушить  `10^6` интов, потом 100 раз удалить 10000 элементов и добавить столько же. Далее как в первом тесте провести 9 итераций удаления-вставки и снова 100 раз удалить 10000 элементов и добавить столько же.

Результаты:

| измерение              | обычный стек, ms | стек на листе, ms |
|------------------------|------------------|-------------------|
| 1                      | 35.666           | 639.821           |
| 2                      | 34.046           | 637.656           |
| 3                      | 36.934           | 642.459           |
| среднее время          | 35.5 $\pm$ 1.4   | 640.0 $\pm$ 2.4   |
| отностельное ускорение | 18.0 $\pm$ 0.8   | 1.00 (baseline)   |

>### Тест 3
>Надо научиться средствами языка генерировать случайные числа из множества {1,2}. Далее сначала довести размер стека до миллиона, а потом выполнить миллион инструкций следующего вида: каждое выпадение единицы добавлять элемент, а на двойку - попать из стека. Засекать время после доведения размера стека до миллиона.

Результаты:

| измерение              | обычный стек, ms | стек на листе, ms |
|------------------------|------------------|-------------------|
| 1                      | 50.944           | 233.643           |
| 2                      | 52.183           | 233.425           |
| 3                      | 50.500           | 232.337           |
| среднее время          | 51.2 $\pm$ 0.9   | 233.1 $\pm$ 0.7   |
| отностельное ускорение | 10.8 $\pm$ 0.2   | 1.00 (baseline)   |

## Вывод
Стек на динамическом массиве существенно быстрее, так как его элементы лежат в памяти подряд, что выгодно для кеша. Результаты в тесте 3 менее показательны, чем в тестах 1 и 2, так как в нем время дополнительно тратися на генерацию случайных чисел.
